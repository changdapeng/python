#! /usr/bin/env python
# Author: CDP
# email: dapeng_chang@163.com

"""
装饰器：
可以在函数执行前和执行后执行一些功能

原理1： 函数整体是可以当做参数进行传递的
原理2： @ + 函数名 --> 装饰器  功能：自动执行outer()函数，并且将下面的函数名f1当做参数传递
原理3： 将outer()函数的返回值重新赋值给f1

知识点1： 定义函数，为了调用， 函数内部不执行
知识点2： 函数名代指函数体，函数名 + ()才表示执行该函数

概要总结： 一旦一个函数被装饰器装饰，那么这个函数就会被装饰器赋值为装饰器返回的内层函数。
进一步理解： 一个函数（1）被装饰器装饰，就相当于，将此函数（1）赋值给新的函数变量（2），
            然后在函数（2）前后各加入新的功能，在赋值回旧的函数（1）
作用： 在不改变原函数的前提下，在原函数执行前后增加功能。
"""




# 原理1： 函数整体是可以当做参数进行传递的
# ------------------------------------
def f11(func):
    print("f11")
    func()

def f22():
    print("f22")

f11(f22)
print("\n")



"""
下面装饰器案例的执行流程：
1、 执行函数f1(): 先讲f1当参数传入outer()装饰器，再执行outer()装饰器。
2、 执行outer()装饰器函数：
    a、 将内部定义函数加载进内存
    b、 返回内部函数，并赋值给被装饰函数f1().
3、 执行重新被赋值的f1()函数：
    a、 先执行   函数执行前的操作
    b、 然后执行 旧的f1()函数
    c、 再执行   函数执行后的操作
"""



# 原理3： 将outer()函数的返回值重新赋值给f1
# --------------------------------------
def outer(func):  # 在被装饰函数执行前执行，并将被装饰函数当做参数传入；函数名代指函数
    def inner(*args, **kwargs):  # 定义函数，为了调用，函数内部不执行，此处和下面func()的传参形式为通用
        print("before！")    # 在函数执行前进行操作
        ret = func(*args, **kwargs)  # 调用函数，并获得原函数的返回值
        print("after！ \n")  # 在函数执行后进行操作
        return ret           # 保证内部函数赋值给f1()函数后，返回值和原f1()返回值一样

    return inner  # 将内层函数返回，并赋值给被装饰函数



# 原理2：@ + 函数名 --> 装饰器  功能：自动执行outer()函数，并且将下面的函数名f1当做参数传递
# ----------------------------------------------------------------------------------
@outer
def f1(name, age):
    print("f1")
    print("name: ", name, "\t", "age: ", age)
    return "原f1()函数返回值"



# 调用函数
# -------
name = "王力宏"
age = 39
ret = f1(name, age)
print(ret)









